{"version":3,"file":"index.js","sources":["../src/common/constants.ts","../src/server/components/socket-server.ts","../src/server/components/hot-reload-server.ts","../src/server/index.ts"],"sourcesContent":["const name = '__webpack_hmr_sever__';\n\nexport const EVENT_NAME = name;\nexport const SERVER_PATH_NAME = name;\nexport const WEBPACK_PLUGIN_NAME = name;\nexport const TIMEOUT = 5000;\n\nexport const STATS_CONFIG = {\n  all: false,\n  cached: true,\n  children: true,\n  modules: true,\n  timings: true,\n  hash: true,\n  errors: true,\n  warnings: true,\n};\n","/* eslint-disable filenames/match-regex */\nimport * as url from 'url';\nimport * as http from 'http';\nimport * as WebSocket from 'ws';\n\nexport interface SocketServerOptions {\n  server: http.Server;\n  path?: string;\n}\n\ntype MessageReply = (message: string) => void;\ntype MessageCallback = (message: string, reply: MessageReply) => void;\n\nexport class SocketServer {\n  private wsServer: WebSocket.Server;\n  private httpServer: http.Server;\n  private path: string | undefined;\n  private callbacks: Array<MessageCallback> = [];\n\n  constructor(options: SocketServerOptions) {\n    this.path = `/${options.path || ''}`;\n    this.httpServer = options.server;\n    this.wsServer = new WebSocket.Server({ noServer: true });\n    this.setupWsServer();\n    this.setupListenersClient();\n  }\n\n  private setupWsServer() {\n    this.httpServer.on('upgrade', (request, socket, head) => {\n      // Dont know how to handle this case\n      /* istanbul ignore next */\n      if (!request.url) {\n        return;\n      }\n\n      // register ws server only pathname;\n      const pathname = url.parse(request.url).pathname;\n      // if options.pathname not set or request is mathc\n      if (pathname === this.path) {\n        this.wsServer.handleUpgrade(request, socket, head, (ws) => {\n          this.wsServer.emit('connection', ws);\n        });\n        return;\n      }\n    });\n  }\n\n  private setupListenersClient() {\n    this.wsServer.on('connection', (client: WebSocket.WebSocket) => {\n      client.on('message', (message: string) => {\n        this.callbacks.forEach((callback) => {\n          const reply: MessageReply = (message: string) => {\n            this.sendMessage(client, message);\n          };\n          callback(message.toString(), reply);\n        });\n      });\n    });\n  }\n\n  private sendMessage(client: WebSocket.WebSocket, message: string): void {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(message);\n    }\n  }\n\n  public sendBroadcast(message: string): void {\n    this.wsServer.clients.forEach((client) => {\n      this.sendMessage(client, message);\n    });\n  }\n\n  public onMessage(callback: MessageCallback) {\n    this.callbacks.push(callback);\n  }\n}\n","/* eslint-disable filenames/match-regex */\n\nimport * as http from 'http';\nimport { SocketServer } from './socket-server';\nimport { SERVER_PATH_NAME, STATS_CONFIG } from '../../common/constants';\nimport { ActionType, Data, Stats, BuildState, BuildStats } from '../../common/types';\n\nexport const processMessage = (action: ActionType, state?: BuildState): string => {\n  return JSON.stringify({\n    action,\n    state,\n  });\n};\n\nexport const statsToData = (stats?: Stats): Data | undefined => {\n  if (!stats) return stats;\n\n  /* istanbul ignore next */ // dont need test destructuring\n  const { hash, time, warnings = [], errors = [] } = stats.toJson(STATS_CONFIG);\n  return {\n    hash,\n    time,\n    warnings,\n    errors,\n  };\n};\n\nexport const buildStatsToState = (buildStats: BuildStats): BuildState => {\n  type keys = keyof typeof buildStats;\n  const state: Partial<BuildState> = {};\n\n  (Object.keys(buildStats) as keys[]).forEach((key) => {\n    state[key] = statsToData(buildStats[key]);\n  });\n  return state as BuildState;\n};\n\nexport class HotReloadServer {\n  private state: BuildState | undefined = undefined;\n  private socketServer: SocketServer;\n  constructor(server: http.Server) {\n    this.socketServer = new SocketServer({\n      server,\n      path: SERVER_PATH_NAME,\n    });\n\n    this.answerResponse();\n  }\n\n  private answerResponse(): void {\n    this.socketServer.onMessage((message, reply) => {\n      // send last state for actions\n      switch (message) {\n        case 'init':\n        case 'check':\n          reply(processMessage(message, this.state));\n          break;\n      }\n    });\n  }\n\n  private sendBroadcast(action: ActionType, state?: BuildState): void {\n    const message = processMessage(action, state);\n    this.socketServer.sendBroadcast(message);\n  }\n\n  // reload modules\n  public reloadModules(buildStats: BuildStats) {\n    const state: BuildState = buildStatsToState(buildStats);\n    this.state = state;\n    this.sendBroadcast('build', state);\n  }\n\n  public refresh = () => {\n    this.sendBroadcast('refresh');\n  };\n}\n","import * as http from 'http';\nimport { WEBPACK_PLUGIN_NAME } from '../common/constants';\nimport { HotReloadServer } from './components/hot-reload-server';\nimport webpack from 'webpack';\n\nimport * as Types from '../common/types';\nexport { Types };\n\nconst auto = (compiler: webpack.Compiler /* client compiler*/, server: http.Server): { refresh: () => void } => {\n  const hotServer = new HotReloadServer(server);\n  compiler.hooks.done.tap(WEBPACK_PLUGIN_NAME, (stats: webpack.Stats) => {\n    hotServer.reloadModules({\n      client: stats,\n    });\n  });\n\n  return {\n    refresh: hotServer.refresh,\n  };\n};\n\nexport default auto;\n\n// factory HotReloadServer\nexport const createHotServer = (server: http.Server): HotReloadServer => {\n  return new HotReloadServer(server);\n};\n"],"names":["STATS_CONFIG","all","cached","children","modules","timings","hash","errors","warnings","SocketServer","wsServer","httpServer","path","callbacks","constructor","options","this","server","WebSocket","Server","noServer","setupWsServer","setupListenersClient","on","request","socket","head","url","parse","pathname","handleUpgrade","ws","emit","client","message","forEach","callback","toString","sendMessage","readyState","OPEN","send","sendBroadcast","clients","onMessage","push","processMessage","action","state","JSON","stringify","buildStatsToState","buildStats","Object","keys","key","stats","time","toJson","statsToData","HotReloadServer","undefined","socketServer","name","answerResponse","reply","reloadModules","refresh","compiler","hotServer","hooks","done","tap"],"mappings":"0ZAAA,MAOaA,EAAe,CAC1BC,KAAK,EACLC,QAAQ,EACRC,UAAU,EACVC,SAAS,EACTC,SAAS,EACTC,MAAM,EACNC,QAAQ,EACRC,UAAU,SCFCC,EACHC,SACAC,WACAC,KACAC,UAAoC,GAE5CC,YAAYC,GACVC,KAAKJ,KAAO,IAAIG,EAAQH,MAAQ,KAChCI,KAAKL,WAAaI,EAAQE,OAC1BD,KAAKN,SAAW,IAAIQ,EAAUC,OAAO,CAAEC,UAAU,IACjDJ,KAAKK,gBACLL,KAAKM,uBAGCD,gBACNL,KAAKL,WAAWY,GAAG,WAAW,CAACC,EAASC,EAAQC,KAG9C,IAAKF,EAAQG,IACX,OAIeA,EAAIC,MAAMJ,EAAQG,KAAKE,WAEvBb,KAAKJ,MACpBI,KAAKN,SAASoB,cAAcN,EAASC,EAAQC,GAAOK,IAClDf,KAAKN,SAASsB,KAAK,aAAcD,SAOjCT,uBACNN,KAAKN,SAASa,GAAG,cAAeU,IAC9BA,EAAOV,GAAG,WAAYW,IACpBlB,KAAKH,UAAUsB,SAASC,IAItBA,EAASF,EAAQG,YAHYH,IAC3BlB,KAAKsB,YAAYL,EAAQC,eAQ3BI,YAAYL,EAA6BC,GAC3CD,EAAOM,aAAerB,EAAUsB,MAClCP,EAAOQ,KAAKP,GAITQ,cAAcR,GACnBlB,KAAKN,SAASiC,QAAQR,SAASF,IAC7BjB,KAAKsB,YAAYL,EAAQC,MAItBU,UAAUR,GACfpB,KAAKH,UAAUgC,KAAKT,IClEjB,MAAMU,EAAiB,CAACC,EAAoBC,IAC1CC,KAAKC,UAAU,CACpBH,OAAAA,EACAC,MAAAA,IAiBSG,EAAqBC,IAEhC,MAAMJ,EAA6B,GAKnC,OAHCK,OAAOC,KAAKF,GAAuBjB,SAASoB,IAC3CP,EAAMO,GAlBiB,CAACC,IAC1B,IAAKA,EAAO,OAAOA,EAGnB,MAAMlD,KAAEA,EAAImD,KAAEA,EAAIjD,SAAEA,EAAW,GAAED,OAAEA,EAAS,IAAOiD,EAAME,OAAO1D,GAChE,MAAO,CACLM,KAAAA,EACAmD,KAAAA,EACAjD,SAAAA,EACAD,OAAAA,IASaoD,CAAYP,EAAWG,OAE/BP,SAGIY,EACHZ,WAAgCa,EAChCC,aACRhD,YAAYG,GACVD,KAAK8C,aAAe,IAAIrD,EAAa,CACnCQ,OAAAA,EACAL,KFxC0BmD,0BE2C5B/C,KAAKgD,iBAGCA,iBACNhD,KAAK8C,aAAalB,WAAU,CAACV,EAAS+B,KAEpC,OAAQ/B,GACN,IAAK,OACL,IAAK,QACH+B,EAAMnB,EAAeZ,EAASlB,KAAKgC,YAMnCN,cAAcK,EAAoBC,GACxC,MAAMd,EAAUY,EAAeC,EAAQC,GACvChC,KAAK8C,aAAapB,cAAcR,GAI3BgC,cAAcd,GACnB,MAAMJ,EAAoBG,EAAkBC,GAC5CpC,KAAKgC,MAAQA,EACbhC,KAAK0B,cAAc,QAASM,GAGvBmB,QAAU,KACfnD,KAAK0B,cAAc,0FClDSzB,GACvB,IAAI2C,EAAgB3C,mBAjBhB,CAACmD,EAAiDnD,KAC7D,MAAMoD,EAAY,IAAIT,EAAgB3C,GAOtC,OANAmD,EAASE,MAAMC,KAAKC,IHNaT,yBGMaP,IAC5Ca,EAAUH,cAAc,CACtBjC,OAAQuB,OAIL,CACLW,QAASE,EAAUF"}