{"version":3,"file":"index.js","sources":["../src/common/constants.ts","../src/server/components/socket-server.ts","../src/server/components/hot-reload-server.ts","../src/server/index.ts"],"sourcesContent":["const name = '__webpack_hmr_sever__';\n\nexport const EVENT_NAME = name;\nexport const SERVER_PATH_NAME = name;\nexport const WEBPACK_PLUGIN_NAME = name;\nexport const TIMEOUT = 5000;\n\nexport const STATS_CONFIG = {\n  all: false,\n  cached: true,\n  children: true,\n  modules: true,\n  timings: true,\n  hash: true,\n  errors: true,\n  warnings: true,\n};\n","/* eslint-disable filenames/match-regex */\nimport * as url from 'url';\nimport * as http from 'http';\nimport * as WebSocket from 'ws';\n\nexport interface SocketServerOptions {\n  server: http.Server;\n  path?: string;\n}\n\ntype MessageReply = (message: string) => void;\ntype MessageCallback = (message: string, reply: MessageReply) => void;\n\nexport class SocketServer {\n  private wsServer: WebSocket.Server;\n  private httpServer: http.Server;\n  private path: string | undefined;\n  private callbacks: Array<MessageCallback> = [];\n\n  constructor(options: SocketServerOptions) {\n    this.path = `/${options.path || ''}`;\n    this.httpServer = options.server;\n    this.wsServer = new WebSocket.Server({ noServer: true });\n    this.setupWsServer();\n    this.setupListenersClient();\n  }\n\n  private setupWsServer() {\n    this.httpServer.on('upgrade', (request, socket, head) => {\n      // Dont know how to handle this case\n      /* istanbul ignore next */\n      if (!request.url) {\n        return;\n      }\n\n      // register ws server only pathname;\n      const pathname = url.parse(request.url).pathname;\n      // if options.pathname not set or request is mathc\n      if (pathname === this.path) {\n        this.wsServer.handleUpgrade(request, socket, head, (ws) => {\n          this.wsServer.emit('connection', ws);\n        });\n        return;\n      }\n    });\n  }\n\n  private setupListenersClient() {\n    this.wsServer.on('connection', (client: WebSocket.WebSocket) => {\n      client.on('message', (message: string) => {\n        this.callbacks.forEach((callback) => {\n          const reply: MessageReply = (message: string) => {\n            this.sendMessage(client, message);\n          };\n          callback(message.toString(), reply);\n        });\n      });\n    });\n  }\n\n  private sendMessage(client: WebSocket.WebSocket, message: string): void {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(message);\n    }\n  }\n\n  public sendBroadcast(message: string): void {\n    this.wsServer.clients.forEach((client) => {\n      this.sendMessage(client, message);\n    });\n  }\n\n  public onMessage(callback: MessageCallback) {\n    this.callbacks.push(callback);\n  }\n}\n","/* eslint-disable filenames/match-regex */\n\nimport * as http from 'http';\nimport * as crypto from 'crypto';\nimport { SocketServer } from './socket-server';\nimport { SERVER_PATH_NAME, STATS_CONFIG } from '../../common/constants';\nimport { ActionType, Data, Stats, BuildState, BuildStats, DataStatsError } from '../../common/types';\nimport webpack from 'webpack';\n\nexport const processMessage = (action: ActionType, state?: BuildState): string => {\n  return JSON.stringify({\n    action,\n    state,\n  });\n};\n\nexport const normalizeModuleName = (moduleName: string) => {\n  // https://webpack.js.org/api/loaders/\n  const match = moduleName.match(/\\.webpack\\[(.*?)\\]!=!/i);\n\n  if (match && match.index) {\n    return moduleName.slice(0, match.index);\n  }\n  return moduleName;\n};\n\nexport const getErrorName = (error: webpack.StatsError): string => {\n  const moduleName = error.moduleName || error.file;\n\n  if (moduleName) {\n    return normalizeModuleName(moduleName);\n  }\n\n  // first line in message\n  return error.message.split('\\n')[0];\n};\n\nexport const md5 = (input: string): string => {\n  return crypto.createHash('md5').update(input).digest('hex');\n};\n\nexport const convertError = (statsError: webpack.StatsError): DataStatsError => {\n  const _name_ = getErrorName(statsError);\n  const _hash_ = md5(_name_) + '.' + md5(statsError.message);\n  return {\n    _name_,\n    _hash_,\n    ...statsError,\n  };\n};\n\nexport const statsToData = (stats?: Stats): Data | undefined => {\n  if (!stats) return stats;\n\n  /* istanbul ignore next */ // dont need test destructuring\n  const { hash, time, warnings = [], errors = [] } = stats.toJson(STATS_CONFIG);\n\n  return {\n    hash,\n    time,\n    warnings: warnings.map(convertError),\n    errors: errors.map(convertError),\n  };\n};\n\nexport const buildStatsToState = (buildStats: BuildStats): BuildState => {\n  type keys = keyof typeof buildStats;\n  const state: Partial<BuildState> = {};\n\n  (Object.keys(buildStats) as keys[]).forEach((key) => {\n    state[key] = statsToData(buildStats[key]);\n  });\n  return state as BuildState;\n};\n\nexport class HotReloadServer {\n  private state: BuildState | undefined = undefined;\n  private socketServer: SocketServer;\n  constructor(server: http.Server) {\n    this.socketServer = new SocketServer({\n      server,\n      path: SERVER_PATH_NAME,\n    });\n\n    this.answerResponse();\n  }\n\n  private answerResponse(): void {\n    this.socketServer.onMessage((message, reply) => {\n      // send last state for actions\n      switch (message) {\n        case 'init':\n        case 'check':\n          reply(processMessage(message, this.state));\n          break;\n      }\n    });\n  }\n\n  private sendBroadcast(action: ActionType, state?: BuildState): void {\n    const message = processMessage(action, state);\n    this.socketServer.sendBroadcast(message);\n  }\n\n  // reload modules\n  public reloadModules(buildStats: BuildStats) {\n    const state: BuildState = buildStatsToState(buildStats);\n    this.state = state;\n    this.sendBroadcast('build', state);\n  }\n\n  public refresh = () => {\n    this.sendBroadcast('refresh');\n  };\n}\n","import * as http from 'http';\nimport { WEBPACK_PLUGIN_NAME } from '../common/constants';\nimport { HotReloadServer } from './components/hot-reload-server';\nimport webpack from 'webpack';\nimport * as Types from '../common/types';\nexport { Types };\n\nexport { statsToData } from './components/hot-reload-server';\n\n// factory HotReloadServer\nexport const createHotServer = (server: http.Server): HotReloadServer => {\n  return new HotReloadServer(server);\n};\n\nexport default (compiler: webpack.Compiler /* client compiler*/, server: http.Server): { refresh: () => void } => {\n  const hotServer = new HotReloadServer(server);\n  compiler.hooks.done.tap(WEBPACK_PLUGIN_NAME, (stats: webpack.Stats) => {\n    hotServer.reloadModules({\n      client: stats,\n    });\n  });\n\n  return {\n    refresh: hotServer.refresh,\n  };\n};\n"],"names":["STATS_CONFIG","all","cached","children","modules","timings","hash","errors","warnings","SocketServer","wsServer","httpServer","path","callbacks","constructor","options","this","server","WebSocket","Server","noServer","setupWsServer","setupListenersClient","on","request","socket","head","url","parse","pathname","handleUpgrade","ws","emit","client","message","forEach","callback","toString","sendMessage","readyState","OPEN","send","sendBroadcast","clients","onMessage","push","processMessage","action","state","JSON","stringify","md5","input","crypto","createHash","update","digest","convertError","statsError","_name_","error","moduleName","file","match","index","slice","normalizeModuleName","split","getErrorName","_hash_","statsToData","stats","time","toJson","map","HotReloadServer","undefined","socketServer","name","answerResponse","reply","reloadModules","buildStats","Object","keys","key","buildStatsToState","refresh","compiler","hotServer","hooks","done","tap"],"mappings":"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"}